# CJ Graph Spec (CJ-GRAPH-1.0)

Version: MVP (EXEC_START, SHOW_TEXT, IF/ELSEIF/ELSE, CONST_BOOL, CONST_NUMBER)

## Formats
- **Forge Project:** `schemaVersion = "CJ-FORGE-PROJECT-1.0"` containing `card`, `graphs`, and `ui` metadata.
- **Graph:** `graphVersion = "CJ-GRAPH-1.0"` with `nodes[]` + `edges[]`.
- **Node registry:** `src/assets/nodeRegistry.json` is the JSON-first source of truth (labels, pins, configSchema, compile hints).

## Node registry (CJ-NODEDEF-1.0)
- Location: `src/assets/nodeRegistry.json`.
- Each node definition includes `nodeType`, `label`, `category`, `description`, `configSchema`, `pins.static[]`, optional `pins.dynamic`, and stub `compile` metadata.
- Palette categories and canvas rendering both resolve directly from the registry (no hardcoded lists in `App.tsx`).
- Dynamic pins in Phase A1 only support the ELSEIF template on IF nodes. Pin ids are deterministic (`elseIfCondIn_{i}` / `elseIfExecOut_{i}`) and always appended after static pins.
- Duplicate pin ids during materialization throw immediately to surface registry drift.

## Pin materialization rules
- Static pins keep the order declared in `nodeRegistry.json`.
- Dynamic ELSEIF pins are generated by clamping `config[elseIfCount]` to the schema min/max (default 0..6) and expanding templates with `{i}` (zero-based id) and `{n}` (1-based label).
- `getDefaultConfig()` reads defaults from the node config schema; IF resolves to `{ elseIfCount: 0 }`.

## Control flow rules
- CONTROL vs DATA pins are enforced at edge creation.
- Each CONTROL **output pin** may have at most one outgoing edge (branching nodes expose multiple output pins instead).
- Cycles in CONTROL edges are invalid.
- `EXEC_START.execOut` must connect to at least one downstream control input.

## Graph IR (CJ-GRAPH-1.0)
- `GraphNode`: `{ id, nodeType, position {x,y}, config }`
- `GraphEdge`: `{ id, edgeKind: "CONTROL" | "DATA", from {nodeId, pinId}, to {nodeId, pinId} }`
- `Graph`: `{ graphVersion: "CJ-GRAPH-1.0", id, label?, nodes: GraphNode[], edges: GraphEdge[] }`
- Graph IR is **editor-only** in Phase A1; canonical runtime steps still live on the card until compilation phases land.
- Graph IR currently lives in React state (in-memory) and is exported with the Forge Project JSON; refresh resets the canvas unless a project is re-imported.

## React Flow adapter (Phase A1)
- `graphNodeToReactFlowNode` maps Graph IR nodes to `{ id, type: "genericNode", position, data: { nodeType, config } }`.
- `graphEdgeToReactFlowEdge` maps Graph IR edges to `{ id, source, target, sourceHandle, targetHandle, label }`.
- Unknown node types render as explicit error nodes on the canvas to expose registry drift.

## Compile mapping (MVP)
- `EXEC_START` → subgraph entry (no step emitted).
- `SHOW_TEXT` → `{ "type": "SHOW_TEXT", "text": node.config.text }`
- `CONST_BOOL` → condition AST `{ "type": "CONST_BOOL", "value": config.value }`
- `CONST_NUMBER` → expression AST `{ "type": "CONST_NUMBER", "value": config.value }`
- `IF` → `IF_ELSE` canonical step with:
  - `condition` from `ifCondIn` DATA edge
  - `then` branch from `thenExecOut`
  - `elseIf[]` pairs from dynamic `elseIfCondIn_{i}` + `elseIfExecOut_{i}`
  - `else` branch from `elseExecOut`

## Validation highlights
- Unknown node types and missing required pins are errors.
- DATA pins must match dataType; CONTROL pins must only connect CONTROL→CONTROL.
- Exec reachability is checked from `EXEC_START`; unreachable nodes are warned.
- Multiple CONTROL edges from the same output pin produce `MULTIPLE_EXEC_OUT` errors.
- Cycles raise `CONTROL_CYCLE` errors.

## Round-trip expectations
- Export/import of Forge Project JSON must preserve node positions and config.
- Compile is debounced in-app; invalid graphs keep the last known good `execution.steps[]`.
