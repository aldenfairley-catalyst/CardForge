# CJ Graph Spec (CJ-GRAPH-1.1)

Version: MVP (EXEC_START, SHOW_TEXT, IF/ELSEIF/ELSE, CONST_BOOL, CONST_NUMBER)

## Formats
- **Forge Project:** `schemaVersion = "CJ-FORGE-PROJECT-1.0"` containing `card`, `graphs`, and `ui` metadata.
- **Graph:** `graphVersion = "CJ-GRAPH-1.1"` with `nodes[]` + `edges[]`.
- **Node registry:** `src/assets/nodeRegistry.json` is the JSON-first source of truth (labels, pins, configSchema, compile hints).

## Node registry (CJ-NODEDEF-1.0)
- Location: `src/assets/nodeRegistry.json`.
- Each node definition includes `nodeType`, `label`, `category`, `description`, `configSchema`, `pins.static[]`, optional `pins.dynamic`, and stub `compile` metadata.
- Palette categories and canvas rendering both resolve directly from the registry (no hardcoded lists in `App.tsx`); categories and node labels are sorted alphabetically for deterministic palettes.
- Dynamic pins support the ELSEIF template on IF nodes. Pin ids are deterministic (`elseIfCondIn_{i}` / `elseIfExecOut_{i}`) and always appended after static pins. Changing `elseIfCount` live re-materializes pins.
- Duplicate pin ids during materialization throw immediately to surface registry drift.

## Pin materialization rules
- Static pins keep the order declared in `nodeRegistry.json`.
- Dynamic ELSEIF pins are generated by clamping `config[elseIfCount]` to the schema min/max (default 0..6) and expanding templates with `{i}` (zero-based id) and `{n}` (1-based label).
- `getDefaultConfig()` reads defaults from the node config schema; IF resolves to `{ elseIfCount: 0 }`.

### Pin cache (Phase A2)
- Graph nodes optionally store `pinsCache: string[]` (ids) to record the pin set last produced by `materializePins(nodeType, config)`.
- The cache is refreshed whenever config changes and is persisted in CJ-GRAPH-1.1 exports for editor diagnostics.
- Dynamic pin changes reconcile edges against the cached/just-computed ids to drop edges that now point at missing handles.

## Control & data connection rules
- CONTROL vs DATA pins are enforced at edge creation (kind + direction must match).
- DATA pins enforce dataType compatibility (`any` wildcard is allowed when a pin omits `dataType`; boolean→boolean, number→number, etc.).
- Target IN pin multiplicity is enforced: default max 1 incoming edge unless `multi: true` or `maxConnections` is set on the pin.
- CONTROL **output pins** may have many outgoing connections (fan-out), but CONTROL **input pins** default to 1 incoming edge unless marked `multi`.
- Cycles in CONTROL edges are rejected at connect time.
- `EXEC_START.execOut` must connect to at least one downstream control input.

## Graph IR (CJ-GRAPH-1.1)
- `GraphNode`: `{ id, nodeType, position {x,y}, config, pinsCache? }`
- `GraphEdge`: `{ id, edgeKind: "CONTROL" | "DATA", dataType?, createdAt?, from {nodeId, pinId}, to {nodeId, pinId} }` — `dataType` is recorded for DATA edges.
- `Graph`: `{ graphVersion: "CJ-GRAPH-1.1", id, label?, nodes: GraphNode[], edges: GraphEdge[] }`
- Graph IR is **editor-only** in Phase A1; canonical runtime steps still live on the card until compilation phases land.
- Graph IR currently lives in React state (in-memory) and is exported with the Forge Project JSON; refresh resets the canvas unless a project is re-imported.

## React Flow adapter (Phase A2)
- Canvas state uses `useNodesState` / `useEdgesState` for stable selection (editing config no longer deselects).
- React Flow node data: `{ nodeType, config, pinsCache }` and the `selected` flag is controlled by local inspector state.
- Graph export/import is round-tripped from React Flow state → CJ-GRAPH-1.1 and back; imports repopulate pinsCache on load.
- Unknown node types render as explicit error nodes on the canvas to expose registry drift, because the single `GraphNode` renderer pulls labels/pins straight from the registry for every node type.
- Palette clicks instantiate new nodes with `getDefaultConfig(nodeType)`; dynamic pin ids are cached immediately for reconciliation.

## Config inspector (Phase A2)
- Selecting a node opens a schema-driven config form. Fields are generated from `configSchema` (string, number, integer, boolean, enum) with min/max clamping and required hints.
- Inspector tabs: Config, Pins (debug view of `materializePins`), and Node JSON (read-only `data` payload including `config` + `pinsCache`).
- Editing config keeps selection stable and immediately re-renders dynamic pins.

## Edge reconciliation (Phase A2)
- Policy: remove edges that reference pins removed by a config change.
- Algorithm: compare `oldPins` vs `newPins` (ids), build `removed`, and filter any edge whose `sourceHandle`/`targetHandle` matches a removed id on the edited node.
- Reconciliation runs in the same transaction as config updates so the canvas never renders dangling handles.

## Compile mapping (MVP)
- `EXEC_START` → subgraph entry (no step emitted).
- `SHOW_TEXT` → `{ "type": "SHOW_TEXT", "text": node.config.text }`
- `CONST_BOOL` → condition AST `{ "type": "CONST_BOOL", "value": config.value }`
- `CONST_NUMBER` → expression AST `{ "type": "CONST_NUMBER", "value": config.value }`
- `IF` → `IF_ELSE` canonical step with:
  - `condition` from `ifCondIn` DATA edge
  - `then` branch from `thenExecOut`
  - `elseIf[]` pairs from dynamic `elseIfCondIn_{i}` + `elseIfExecOut_{i}`
  - `else` branch from `elseExecOut`

## Validation highlights
- Unknown node types and missing required pins are errors.
- DATA pins must match dataType; CONTROL pins must only connect CONTROL→CONTROL.
- Exec reachability is checked from `EXEC_START`; unreachable nodes are warned.
- Multiple CONTROL edges from the same output pin produce `MULTIPLE_EXEC_OUT` errors.
- Cycles raise `CONTROL_CYCLE` errors.

## Round-trip expectations
- Export/import of Forge Project JSON must preserve node positions and config.
- Compile is debounced in-app; invalid graphs keep the last known good `execution.steps[]`.
